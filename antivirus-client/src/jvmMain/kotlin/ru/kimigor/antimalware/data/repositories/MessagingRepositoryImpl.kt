package ru.kimigor.antimalware.data.repositories

import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.withContext
import ru.kimigor.antimalware.data.api.AntivirusApi
import ru.kimigor.antimalware.data.models.ApiMessage
import ru.kimigor.antimalware.data.models.MessageStatus
import ru.kimigor.antimalware.data.models.ScannerCacheData
import ru.kimigor.antimalware.data.models.structs.MessageBodyProtectionStruct
import ru.kimigor.antimalware.domain.models.ScanState
import ru.kimigor.antimalware.domain.models.ScannerEntryStatus
import ru.kimigor.antimalware.domain.models.ScannerStatus
import ru.kimigor.antimalware.domain.repositories.MessagingRepository

class MessagingRepositoryImpl(
    private val antivirusApi: AntivirusApi,
    private val ioDispatcher: CoroutineDispatcher
): MessagingRepository {
    override suspend fun isProtectionEnabled() = withContext(ioDispatcher) {
        when (val response = antivirusApi.isProtectionEnabled()) {
            is ApiMessage.Ok -> {
                val bodyBytes = response.body.body ?: return@withContext ApiMessage.Ok(false)
                val body = MessageBodyProtectionStruct.create(bodyBytes)
                ApiMessage.Ok(body.status == MessageBodyProtectionStruct.ENABLED)
            }
            is ApiMessage.Fail -> {
                ApiMessage.Fail(
                    description = response.description,
                    errorCode = response.errorCode
                )
            }
        }
    }

    override suspend fun enableProtection() = withContext(ioDispatcher) {
        antivirusApi.enableProtection()
    }

    override suspend fun disableProtection() = withContext(ioDispatcher) {
        antivirusApi.disableProtection()
    }

    override suspend fun startScan(path: String) = withContext(ioDispatcher) {
        antivirusApi.startScan(path)
    }

    override suspend fun pauseScan() = withContext(ioDispatcher) {
        antivirusApi.pauseScan()
    }

    override suspend fun resumeScan() = withContext(ioDispatcher) {
        antivirusApi.resumeScan()
    }

    override suspend fun stopScan() = withContext(ioDispatcher) {
        antivirusApi.stopScan()
    }

    @OptIn(FlowPreview::class)
    override fun scanState(scope: CoroutineScope): StateFlow<ScanState> =
        antivirusApi.scannerCacheData
            .map(::scanState)
            .debounce(500)
            .stateIn(
                scope = scope,
                started = SharingStarted.Eagerly,
                initialValue = scanState(antivirusApi.scannerCacheData.value)
            )

    private fun scanState(data: ScannerCacheData?) = when {
        data == null -> {
            ScanState.Empty
        }

        data.scannerStatus == ScannerStatus.SCANNING.id ||
        data.scannerStatus == ScannerStatus.PAUSED.id -> {
            ScanState.Running(
                entries = data.entries.map { entry ->
                    entry.first to ScannerEntryStatus.byId(entry.second)
                },
            )
        }

        else -> {
            val virusesEntries = data.entries
                .filter { it.second == ScannerEntryStatus.SCANNED_INFECTED.id }

            if (virusesEntries.isNotEmpty()) {
                ScanState.VirusesDetected(
                    viruses = virusesEntries.map(Pair<String, Byte>::first)
                )
            } else {
                ScanState.Empty
            }
        }
    }
}